<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' https://drive.google.com https://corsproxy.io https:;">
    <title>PLC Ladder Diagram Simulator</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <h1>üîå PLC Ladder Diagram Simulator</h1>
            <div class="header-controls">
                <button id="newDiagram" class="btn btn-secondary">New</button>
                <button id="saveDiagram" class="btn btn-secondary">Save</button>
                <button id="loadDiagram" class="btn btn-secondary">Load</button>
                <button id="librariesBtn" class="btn btn-info">üìö Libraries</button>
                <button id="clearDiagram" class="btn btn-danger">Clear</button>
                <div style="border-left: 2px solid #555; margin: 0 10px; height: 30px;"></div>
                <button id="viewLadder" class="btn btn-primary">üìä Ladder</button>
                <button id="viewDrawing" class="btn btn-secondary">‚úèÔ∏è Schematic Drawing</button>
                <button id="view3DModels" class="btn btn-secondary" style="margin-left: auto;">üé≤ 3D Models</button>
            </div>
        </header>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Left Sidebar - Component Palette -->
            <aside class="sidebar sidebar-left">
                <!-- Ladder Diagram Components (shown in ladder view) -->
                <div id="ladder-components" class="sidebar-content">
                    <h2>Components</h2>
                    
                    <div class="component-category">
                    <h3>Input/Output</h3>
                    <div class="component-grid compact-grid">
                        <button class="component-btn icon-only" data-type="NO_CONTACT" title="Normally Open Contact">
                            <span class="component-icon">‚î§ ‚îú</span>
                        </button>
                        <button class="component-btn icon-only" data-type="NC_CONTACT" title="Normally Closed Contact">
                            <span class="component-icon">‚î§/‚îú</span>
                        </button>
                        <button class="component-btn icon-only" data-type="OUTPUT_COIL" title="Output Coil">
                            <span class="component-icon">( )</span>
                        </button>
                    </div>
                </div>

                <div class="component-category">
                    <h3>Timers</h3>
                    <div class="component-grid compact-grid">
                        <button class="component-btn icon-only" data-type="TON" title="Timer On-Delay">
                            <span class="component-icon">TON</span>
                        </button>
                        <button class="component-btn icon-only" data-type="TOF" title="Timer Off-Delay">
                            <span class="component-icon">TOF</span>
                        </button>
                        <button class="component-btn icon-only" data-type="TP" title="Timer Pulse">
                            <span class="component-icon">TP</span>
                        </button>
                    </div>
                </div>

                <div class="component-category">
                    <h3>Wiring</h3>
                    <div class="component-grid compact-grid">
                        <button class="component-btn icon-only" data-type="HORIZONTAL_WIRE" title="Horizontal Wire">
                            <span class="component-icon">‚îÄ</span>
                        </button>
                        <button class="component-btn icon-only" data-type="VERTICAL_WIRE" title="Vertical Wire">
                            <span class="component-icon">‚îÇ</span>
                        </button>
                        <button class="component-btn icon-only" data-type="BRANCH_POINT" title="Branch Point">
                            <span class="component-icon">‚î¨</span>
                        </button>
                        <button class="component-btn icon-only" data-type="CORNER_DOWN_RIGHT" title="L1 Corner (‚îî)">
                            <span class="component-icon">‚îî</span>
                        </button>
                        <button class="component-btn icon-only" data-type="CORNER_DOWN_LEFT" title="L2 Corner (‚îò)">
                            <span class="component-icon">‚îò</span>
                        </button>
                        <button class="component-btn icon-only" data-type="CORNER_UP_RIGHT" title="Corner Up-Right (‚îå)">
                            <span class="component-icon">‚îå</span>
                        </button>
                        <button class="component-btn icon-only" data-type="CORNER_UP_LEFT" title="Corner Up-Left (‚îê)">
                            <span class="component-icon">‚îê</span>
                        </button>
                    </div>
                </div>

                <div class="tool-section">
                    <h3>Tools</h3>
                    <button id="deleteTool" class="btn btn-danger btn-block">
                        üóëÔ∏è Delete Mode
                    </button>
                    <button id="selectTool" class="btn btn-secondary btn-block">
                        üëÜ Select Mode
                    </button>
                </div>

                <div class="pin-list-section">
                    <h3>Pin Configuration</h3>
                    <div class="pin-list-container">
                        <div class="pin-category">
                            <h4>Inputs</h4>
                            <div id="inputPinList" class="pin-items"></div>
                        </div>
                        <div class="pin-category">
                            <h4>Feedbacks</h4>
                            <div id="feedbackPinList" class="pin-items"></div>
                        </div>
                        <div class="pin-category">
                            <h4>Outputs</h4>
                            <div id="outputPinList" class="pin-items"></div>
                        </div>
                    </div>
                </div>
                </div>
                <!-- End of Ladder Components -->

                <!-- Drawing Components (shown in Drawing view, initially hidden) -->
                <div id="drawing-components" class="sidebar-content" style="display: none;">
                    <h2>Drawing Components</h2>
                    
                    <div class="component-category">
                        <h3>Quick Actions</h3>
                        <button id="clearDrawing" class="btn btn-secondary btn-block">
                            üóëÔ∏è Clear Canvas
                        </button>
                        <button id="saveDrawing" class="btn btn-success btn-block">
                            üíæ Save Schematic
                        </button>
                        <button id="loadDrawing" class="btn btn-info btn-block">
                            üìÇ Load Schematic
                        </button>
                    </div>

                    <div class="component-category">
                        <h3>PLC Components</h3>
                        <div class="component-grid">
                            <button class="drawing-component-btn" data-component="plc">
                                <span class="component-icon">üñ•Ô∏è</span>
                                <span class="component-label">PLC</span>
                            </button>
                            <button class="drawing-component-btn" data-component="power-supply">
                                <span class="component-icon">üîå</span>
                                <span class="component-label">Power Supply</span>
                            </button>
                            <button class="drawing-component-btn" data-component="io-module">
                                <span class="component-icon">üìä</span>
                                <span class="component-label">I/O Module</span>
                            </button>
                        </div>
                    </div>

                    <div class="component-category">
                        <h3>Field Devices</h3>
                        <div class="component-grid">
                            <button class="drawing-component-btn" data-component="motor">
                                <span class="component-icon">‚öôÔ∏è</span>
                                <span class="component-label">Motor</span>
                            </button>
                            <button class="drawing-component-btn" data-component="sensor">
                                <span class="component-icon">üì°</span>
                                <span class="component-label">Sensor</span>
                            </button>
                            <button class="drawing-component-btn" data-component="button">
                                <span class="component-icon">üîò</span>
                                <span class="component-label">Button</span>
                            </button>
                            <button class="drawing-component-btn" data-component="led">
                                <span class="component-icon">üí°</span>
                                <span class="component-label">Indicator</span>
                            </button>
                            <button class="drawing-component-btn" data-component="relay">
                                <span class="component-icon">üîÑ</span>
                                <span class="component-label">Relay</span>
                            </button>
                            <button class="drawing-component-btn" data-component="terminal">
                                <span class="component-icon">üîå</span>
                                <span class="component-label">Terminal</span>
                            </button>
                        </div>
                    </div>

                    <div class="component-category">
                        <h3>Tools</h3>
                        <div class="component-grid">
                            <button class="drawing-tool-btn" data-tool="wire">
                                <span class="component-icon">üìè</span>
                                <span class="component-label">Wire Tool</span>
                            </button>
                            <button class="drawing-tool-btn" data-tool="select">
                                <span class="component-icon">üëÜ</span>
                                <span class="component-label">Select</span>
                            </button>
                            <button class="drawing-tool-btn" data-tool="delete">
                                <span class="component-icon">‚ùå</span>
                                <span class="component-label">Delete</span>
                            </button>
                        </div>
                    </div>

                    <div class="component-category">
                        <h3>Wire Colors</h3>
                        <div class="component-grid">
                            <button class="wire-color-btn active" data-color="#000000" title="Black">
                                <span class="component-icon" style="background: #000000; border-radius: 50%; width: 20px; height: 20px; display: inline-block; border: 2px solid #666;"></span>
                                <span class="component-label">Black</span>
                            </button>
                            <button class="wire-color-btn" data-color="#ff0000" title="Red">
                                <span class="component-icon" style="background: #ff0000; border-radius: 50%; width: 20px; height: 20px; display: inline-block; border: 2px solid #666;"></span>
                                <span class="component-label">Red</span>
                            </button>
                            <button class="wire-color-btn" data-color="#0066ff" title="Blue">
                                <span class="component-icon" style="background: #0066ff; border-radius: 50%; width: 20px; height: 20px; display: inline-block; border: 2px solid #666;"></span>
                                <span class="component-label">Blue</span>
                            </button>
                            <button class="wire-color-btn" data-color="#00cc00" title="Green">
                                <span class="component-icon" style="background: #00cc00; border-radius: 50%; width: 20px; height: 20px; display: inline-block; border: 2px solid #666;"></span>
                                <span class="component-label">Green</span>
                            </button>
                            <button class="wire-color-btn" data-color="#ffcc00" title="Yellow">
                                <span class="component-icon" style="background: #ffcc00; border-radius: 50%; width: 20px; height: 20px; display: inline-block; border: 2px solid #666;"></span>
                                <span class="component-label">Yellow</span>
                            </button>
                            <button class="wire-color-btn" data-color="#ffffff" title="White">
                                <span class="component-icon" style="background: #ffffff; border-radius: 50%; width: 20px; height: 20px; display: inline-block; border: 2px solid #666;"></span>
                                <span class="component-label">White</span>
                            </button>
                        </div>
                    </div>
                </div>
                <!-- End of Drawing Components -->

                <!-- 3D Model Components (shown in 3D view, initially hidden) -->
                <div id="model-components" class="sidebar-content" style="display: none;">
                    <h2>3D Models</h2>
                    
                    <div class="component-category">
                        <p id="model-catalog-info" style="font-size: 11px; color: #888; margin: 5px 0 15px 0;">
                            Loading STL catalog...
                        </p>
                    </div>
                    
                    <div id="model-list-buttons" class="component-category">
                        <button disabled class="btn btn-secondary btn-block">
                            ‚è≥ Loading models...
                        </button>
                    </div>
                </div>
                <!-- End of 3D Model Components -->

            </aside>

            <!-- Center - Ladder Grid -->
            <main class="ladder-workspace" id="ladder-container">
                <div class="workspace-controls">
                    <button id="runPauseSimulation" class="btn btn-success">‚ñ∂Ô∏è Run</button>
                    <button id="resetSimulation" class="btn btn-warning">üîÑ Reset</button>
                    <span class="status-indicator">
                        <span id="statusDot" class="status-dot status-stopped"></span>
                        <span id="statusText">Stopped</span>
                    </span>
                    <div class="timer-controls">
                        <label for="timeElapsed">Time:</label>
                        <span id="timeElapsed" class="time-display">0.00s</span>
                        <label for="scanCycle" style="margin-left: 15px;">Scan Cycle:</label>
                        <input type="number" id="scanCycle" min="10" max="5000" value="100" step="10">
                        <span>ms</span>
                        <label for="speedMultiplier" style="margin-left: 15px;">Speed:</label>
                        <select id="speedMultiplier">
                            <option value="0.1">0.1x (Slow)</option>
                            <option value="0.25">0.25x</option>
                            <option value="0.5">0.5x</option>
                            <option value="1" selected>1x (Normal)</option>
                            <option value="2">2x (Fast)</option>
                            <option value="5">5x</option>
                            <option value="10">10x (Very Fast)</option>
                        </select>
                    </div>
                </div>

                <div class="grid-container">
                    <canvas id="ladderCanvas"></canvas>
                </div>

                <div class="grid-info">
                    <span id="cursorPosition">Position: (-, -)</span>
                    <span id="selectedComponent">Selected: None</span>
                </div>
            </main>

            <!-- 2D Drawing View (initially hidden) -->
            <main class="drawing-workspace" style="display: none;">
                <div id="drawing-container" style="width: 100%; height: calc(100vh - 120px); background: #ffffff; position: relative;">
                    <!-- Drawing canvas will be inserted here -->
                </div>
            </main>

            <!-- 3D Model View (initially hidden) -->
            <main class="model-workspace" style="display: none;">
                <div id="model-viewer-container" style="width: 100%; height: calc(100vh - 120px); background: #f0f0f0; position: relative;">
                    <!-- Three.js canvas will be inserted here -->
                    
                    <!-- ViewCube - Top Right Corner (Canvas-based) -->
                    <div id="viewCubeContainer" style="position: absolute; top: 20px; right: 20px; z-index: 100;">
                        <div style="text-align: center; margin-bottom: 5px; font-size: 11px; color: #555; font-weight: bold;">View Cube</div>
                        <canvas id="viewCubeCanvas" width="150" height="150" style="cursor: pointer; background: rgba(255,255,255,0.1); border-radius: 8px;"></canvas>
                    </div>
                    
                    <div id="model-viewer-status" style="position: absolute; bottom: 20px; left: 20px; background: rgba(0,0,0,0.7); color: white; padding: 10px 15px; border-radius: 5px; font-size: 12px; font-family: monospace; max-height: 150px; overflow-y: auto; max-width: 400px; z-index: 10;">
                        <div class="log-entry">Ready to load models...</div>
                    </div>
                </div>
            </main>

            <!-- Right Sidebar - I/O and Properties -->
            <aside class="sidebar sidebar-right">
                <!-- Ladder View Panels (shown when in ladder view) -->
                <div id="ladder-right-panels">
                    <!-- Input Panel -->
                    <div class="io-panel">
                        <h2>Inputs</h2>
                        <div id="inputList" class="io-list">
                            <p class="empty-message">No inputs assigned</p>
                        </div>
                        <button id="addInput" class="btn btn-secondary btn-small">+ Add Input</button>
                    </div>

                    <!-- Feedback Panel -->
                    <div class="io-panel">
                        <h2>Feedbacks</h2>
                        <div id="feedbackList" class="io-list">
                            <p class="empty-message">No feedbacks available</p>
                        </div>
                    </div>

                    <!-- Output Panel -->
                    <div class="io-panel">
                        <h2>Outputs</h2>
                        <div id="outputList" class="io-list">
                            <p class="empty-message">No outputs assigned</p>
                        </div>
                        <button id="addOutput" class="btn btn-secondary btn-small">+ Add Output</button>
                    </div>

                    <!-- Properties Panel -->
                    <div class="properties-panel">
                        <h2>Properties</h2>
                        <div id="propertiesContent" class="properties-content">
                            <p class="empty-message">Select a component to view properties</p>
                        </div>
                    </div>
                </div>

                <!-- 3D Model View Panels (shown when in 3D model view) -->
                <div id="model-right-panels" style="display: none;">
                    <!-- Mounting Configuration -->
                    <div class="io-panel">
                        <h2>üìê Mounting Setup</h2>
                        <div style="padding: 10px;">
                            <label style="font-size: 11px; color: #888; display: block; margin-bottom: 5px;">Mounting Type:</label>
                            <select id="mountingType" style="width: 100%; padding: 5px; margin-bottom: 10px; background: #2c3e50; color: white; border: 1px solid #555; border-radius: 3px;">
                                <option value="box">Control Cabinet (Box)</option>
                                <option value="plate">Mounting Plate (Flat)</option>
                                <option value="shelf">Shelf (Open Front)</option>
                            </select>
                            
                            <label style="font-size: 11px; color: #888; display: block; margin-top: 10px;">Width (mm):</label>
                            <input type="number" id="mountingWidth" value="300" min="200" max="2000" step="50" style="width: 100%; padding: 5px; background: #2c3e50; color: white; border: 1px solid #555; border-radius: 3px;">
                            
                            <label style="font-size: 11px; color: #888; display: block; margin-top: 8px;">Height (mm):</label>
                            <input type="number" id="mountingHeight" value="400" min="200" max="2000" step="50" style="width: 100%; padding: 5px; background: #2c3e50; color: white; border: 1px solid #555; border-radius: 3px;">
                            
                            <label style="font-size: 11px; color: #888; display: block; margin-top: 8px;">Depth (mm):</label>
                            <input type="number" id="mountingDepth" value="200" min="100" max="1000" step="50" style="width: 100%; padding: 5px; background: #2c3e50; color: white; border: 1px solid #555; border-radius: 3px;">
                            
                            <button id="applyMounting" class="btn btn-success btn-small" style="margin-top: 10px; width: 100%;">Apply Changes</button>
                        </div>
                    </div>

                    <!-- View Mode Controls -->
                    <div class="io-panel">
                        <h2>üëÅÔ∏è View Mode</h2>
                        <div style="padding: 10px;">
                            <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                                <button id="view2D" class="btn btn-success btn-small" style="flex: 1; font-size: 11px;">üìê 2D Top View</button>
                                <button id="view3D" class="btn btn-secondary btn-small" style="flex: 1; font-size: 11px;">üé≤ 3D View</button>
                            </div>
                            <p style="font-size: 10px; color: #888; margin: 0;">
                                <strong>2D Mode:</strong> Arrange items from top-down view (easier layout)<br>
                                <strong>3D Mode:</strong> See full 3D perspective of your assembly
                            </p>
                        </div>
                    </div>

                    <!-- Physics Controls -->
                    <div class="io-panel">
                        <h2>‚öôÔ∏è Physics</h2>
                        <div style="padding: 10px;">
                            <label style="display: flex; align-items: center; margin-bottom: 10px;">
                                <input type="checkbox" id="enableGravity" checked style="margin-right: 8px;">
                                <span>Enable Gravity</span>
                            </label>
                            <label style="display: flex; align-items: center; margin-bottom: 10px;">
                                <input type="checkbox" id="enableSnapping" checked style="margin-right: 8px;">
                                <span>Snap to Surface</span>
                            </label>
                            <div style="margin-top: 10px;">
                                <label style="font-size: 11px; color: #888;">Snap Distance:</label>
                                <input type="range" id="snapDistance" min="5" max="200" value="20" style="width: 100%;">
                                <span id="snapDistanceValue" style="font-size: 11px; color: #888;">20mm</span>
                            </div>
                        </div>
                    </div>

                    <!-- Port Editor -->
                    <div class="io-panel">
                        <h2>üîå Connection Ports</h2>
                        <div style="padding: 10px;">
                            <div style="margin-bottom: 10px;">
                                <button id="togglePortEditMode" class="btn btn-secondary btn-small" style="width: 100%;">
                                    üìç Edit Ports Mode: OFF
                                </button>
                            </div>
                            <div id="portEditorControls" style="display: none;">
                                <p style="font-size: 10px; color: #888; margin: 5px 0;">
                                    Click on a model to add connection ports. Shift+Click to remove ports.
                                </p>
                                <div style="margin: 10px 0;">
                                    <label style="font-size: 11px; color: #888;">Port Label:</label>
                                    <input type="text" id="portLabel" placeholder="e.g., L1, N, IN1" style="width: 100%; padding: 5px; background: #2c3e50; color: white; border: 1px solid #555; border-radius: 3px;">
                                </div>
                                <div style="margin: 10px 0;">
                                    <label style="font-size: 11px; color: #888;">Port Type:</label>
                                    <select id="portType" style="width: 100%; padding: 5px; background: #2c3e50; color: white; border: 1px solid #555; border-radius: 3px;">
                                        <option value="power">‚ö° Power (L/N/PE)</option>
                                        <option value="input">üì• Input Signal</option>
                                        <option value="output">üì§ Output Signal</option>
                                        <option value="data">üíæ Data/Comm</option>
                                    </select>
                                </div>
                                <div style="margin: 10px 0;">
                                    <label style="font-size: 11px; color: #888;">Port Size (mm):</label>
                                    <input type="number" id="portSize" value="10" min="5" max="50" style="width: 100%; padding: 5px; background: #2c3e50; color: white; border: 1px solid #555; border-radius: 3px;">
                                </div>
                                <button id="savePortsToFile" class="btn btn-success btn-small" style="width: 100%; margin-top: 5px;">
                                    üíæ Export Port Config
                                </button>
                                <button id="loadPortsFromFile" class="btn btn-secondary btn-small" style="width: 100%; margin-top: 5px;">
                                    üìÅ Import Port Config
                                </button>
                            </div>
                            <div id="portsList" style="margin-top: 10px; font-size: 11px; max-height: 150px; overflow-y: auto;">
                                <p style="color: #888; font-size: 10px;">No ports defined</p>
                            </div>
                        </div>
                    </div>

                    <!-- Selected Object Properties -->
                    <div class="properties-panel">
                        <h2>üì¶ Selected Object</h2>
                        <div id="model-properties-content" class="properties-content">
                            <p class="empty-message">Select a component to view properties</p>
                        </div>
                    </div>

                    <!-- Scene Objects List -->
                    <div class="io-panel">
                        <h2>üóÇÔ∏è Scene Objects</h2>
                        <div id="scene-objects-list" style="padding: 5px; max-height: 150px; overflow-y: auto;">
                            <p class="empty-message">No objects in scene</p>
                        </div>
                        <button id="clearScene" class="btn btn-danger btn-small" style="margin-top: 10px;">Clear All</button>
                    </div>
                </div>
            </aside>
        </div>
    </div>

    <!-- Modal for Pin Assignment -->
    <div id="pinModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2 id="modalTitle">Assign Pin</h2>
            <form id="pinAssignmentForm">
                <div class="form-group">
                    <label for="pinNumber">Pin:</label>
                    <select id="pinNumber" required>
                        <option value="">Select pin...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="pinLabel">Label:</label>
                    <input type="text" id="pinLabel" placeholder="e.g., Start Button" required>
                </div>
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Assign</button>
                    <button type="button" class="btn btn-secondary" id="cancelPin">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Modal for Timer Configuration -->
    <div id="timerModal" class="modal">
        <div class="modal-content">
            <span class="close-timer">&times;</span>
            <h2 id="timerModalTitle">Configure Timer</h2>
            <form id="timerConfigForm">
                <div class="form-group">
                    <label for="timerLabel">Label:</label>
                    <input type="text" id="timerLabel" placeholder="e.g., Delay Start" required>
                </div>
                <div class="form-group">
                    <label for="timerPreset">Preset Time (seconds):</label>
                    <input type="number" id="timerPreset" min="0.1" max="3600" step="0.1" value="1.0" required>
                </div>
                <div class="form-group">
                    <label>Timer Type:</label>
                    <p id="timerTypeDisplay" style="color: #9C27B0; font-weight: bold;">TON - On Delay</p>
                </div>
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Save</button>
                    <button type="button" class="btn btn-secondary" id="cancelTimer">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Modal for Libraries -->
    <div id="librariesModal" class="modal">
        <div class="modal-content">
            <span class="close-libraries">&times;</span>
            <h2>Example Circuit Libraries</h2>
            <div class="library-container">
                <p>Load a pre-built circuit example:</p>
                <div id="libraryList" class="library-list">
                    <button class="library-item" data-library="simple-on-off">
                        <strong>Simple ON/OFF Circuit</strong>
                        <p>Basic start/stop control with one input and one output</p>
                    </button>
                    <button class="library-item" data-library="and-circuit">
                        <strong>AND Circuit</strong>
                        <p>Two inputs in series (both must be ON)</p>
                    </button>
                    <button class="library-item" data-library="or-circuit">
                        <strong>OR Circuit</strong>
                        <p>Two inputs in parallel (either can be ON)</p>
                    </button>
                    <button class="library-item" data-library="complex-and-or">
                        <strong>Complex AND/OR Circuit</strong>
                        <p>Combination of series and parallel logic</p>
                    </button>
                    <button class="library-item" data-library="latch-circuit">
                        <strong>Latch Circuit</strong>
                        <p>Start/stop with feedback latching</p>
                    </button>
                    <button class="library-item" data-library="timer-circuit">
                        <strong>Timer Circuit</strong>
                        <p>Delayed output using TON timer</p>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Analysis Library -->
    <script src="analysis-v2.js"></script>
    
    <!-- Three.js Library (for 3D viewer) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
    
    <!-- Rapier Physics Engine -->
    <script src="https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.11.2/rapier.min.js"></script>
    
    <!-- PLC Simulator Modules (Load order is important!) -->
    <!-- 1. Configuration & Constants -->
    <script src="js/ladder/config.js"></script>
    
    <!-- 2. State Management -->
    <script src="js/ladder/state.js"></script>
    
    <!-- 3. DOM References -->
    <script src="js/ladder/dom.js"></script>
    
    <!-- 4. Utility Functions -->
    <script src="js/ladder/canvas.js"></script>
    <script src="js/ladder/keyboard.js"></script>
    
    <!-- 5. Core Features -->
    <script src="js/ladder/components.js"></script>
    <script src="js/ladder/modals.js"></script>
    <script src="js/ladder/rendering.js"></script>
    <script src="js/ladder/ui.js"></script>
    <script src="js/ladder/simulation.js"></script>
    <script src="js/ladder/diagram.js"></script>
    
    <!-- 6. Initialization -->
    <script src="js/ladder/init.js"></script>
    
    <!-- 7. Entry Point -->
    <script src="js/ladder/main.js"></script>
    
    <!-- 2D Drawing System -->
    <script src="js/drawing/canvas.js"></script>
    <script src="js/drawing/init.js"></script>
    
    <!-- View Toggle Controls -->
    <script src="js/shared/viewSwitching.js"></script>
    
    <!-- 3D Model Viewer Script -->
    <script>
        // Interactive 3D Scene Manager with Physics
        class Interactive3DScene {
            constructor(container, statusDiv) {
                this.container = container;
                this.statusDiv = statusDiv;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.orbitControls = null;
                this.transformControls = null;
                this.world = null; // Rapier physics world
                this.rigidBodies = new Map(); // mesh -> rigidBody mapping
                this.sceneObjects = []; // Track all placed objects
                this.selectedObject = null;
                this.snapEnabled = true;
                this.snapDistance = 20;
                this.gravityEnabled = true;
                this.mountingSurfaces = []; // Walls, shelves, mounting plates
                this.boundaryWalls = []; // Invisible collision walls
                
                // Mounting configuration (halved from original)
                this.mountingConfig = {
                    type: 'box', // 'box', 'plate', 'shelf'
                    width: 300,
                    height: 400,
                    depth: 200
                };
                
                // Port Editor system
                this.portEditMode = false;
                this.modelPorts = new Map(); // modelName -> [{position, label, type, size}]
                this.portMarkers = []; // Visual port indicators
                
                this.init();
            }
            
            async init() {
                this.setupScene();
                this.setupLighting();
                this.setupControls();
                await this.setupPhysics();
                this.createMounting();
                this.animate();
                this.log('‚úÖ Interactive 3D Scene initialized', 'success');
            }
            
            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf0f0f0); // Light white/gray background
                
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    this.container.clientWidth / this.container.clientHeight,
                    0.1,
                    10000
                );
                // Start in 2D top-view for easier arrangement
                this.camera.position.set(0, 800, 0);
                this.camera.lookAt(0, 0, 0);
                this.is2DMode = true; // Track view mode
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.container.insertBefore(this.renderer.domElement, this.statusDiv);
            }
            
            setupLighting() {
                // Bright ambient light for well-lit scene
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                this.scene.add(ambientLight);
                
                // Main directional light (sun-like)
                const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight1.position.set(200, 300, 200);
                directionalLight1.castShadow = true;
                directionalLight1.shadow.mapSize.width = 2048;
                directionalLight1.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight1);
                
                // Fill light from opposite side
                const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
                directionalLight2.position.set(-200, 200, -200);
                this.scene.add(directionalLight2);
                
                // Additional top light
                const topLight = new THREE.DirectionalLight(0xffffff, 0.3);
                topLight.position.set(0, 500, 0);
                this.scene.add(topLight);
            }
            
            setupControls() {
                // Orbit controls for camera
                this.orbitControls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.orbitControls.enableDamping = true;
                this.orbitControls.dampingFactor = 0.05;
                
                // Start locked in 2D top-view mode
                this.orbitControls.enableRotate = false;
                this.orbitControls.maxPolarAngle = 0;
                this.orbitControls.minPolarAngle = 0;
                
                // Transform controls for object manipulation
                this.transformControls = new THREE.TransformControls(this.camera, this.renderer.domElement);
                this.transformControls.addEventListener('dragging-changed', (event) => {
                    this.orbitControls.enabled = !event.value;
                    
                    // When user releases object after dragging
                    if (!event.value && this.selectedObject) {
                        const body = this.rigidBodies.get(this.selectedObject);
                        if (body) {
                            // Make it dynamic so it falls
                            body.setBodyType(RAPIER.RigidBodyType.Dynamic, true);
                            // Reset velocities
                            body.setLinvel({ x: 0, y: 0, z: 0 }, true);
                            body.setAngvel({ x: 0, y: 0, z: 0 }, true);
                            this.log(`üéØ Released ${this.selectedObject.userData.name} - falling with gravity`, 'info');
                        }
                    }
                });
                this.transformControls.addEventListener('objectChange', () => {
                    if (this.selectedObject) {
                        this.checkSnapping(this.selectedObject);
                        this.updatePropertiesPanel();
                    }
                });
                this.scene.add(this.transformControls);
                
                // Handle window resize
                const resizeObserver = new ResizeObserver(() => {
                    this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                });
                resizeObserver.observe(this.container);
                
                // Mouse picking
                this.setupMousePicking();
                
                // Setup ViewCube
                this.setupViewCube();
            }
            
            setupViewCube() {
                // Create mini Three.js scene for ViewCube
                const canvas = document.getElementById('viewCubeCanvas');
                if (!canvas) return;
                
                this.viewCubeScene = new THREE.Scene();
                this.viewCubeCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
                this.viewCubeCamera.position.set(0, 0, 3);
                
                this.viewCubeRenderer = new THREE.WebGLRenderer({ 
                    canvas: canvas, 
                    alpha: true,
                    antialias: true
                });
                this.viewCubeRenderer.setSize(150, 150);
                this.viewCubeRenderer.setClearColor(0x000000, 0);
                
                // Create cube geometry with different colors per face
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const materials = [
                    new THREE.MeshBasicMaterial({ color: 0xf39c12 }), // Right - Orange
                    new THREE.MeshBasicMaterial({ color: 0xe74c3c }), // Left - Red
                    new THREE.MeshBasicMaterial({ color: 0x3498db }), // Top - Blue
                    new THREE.MeshBasicMaterial({ color: 0x95a5a6 }), // Bottom - Gray
                    new THREE.MeshBasicMaterial({ color: 0x2ecc71 }), // Front - Green
                    new THREE.MeshBasicMaterial({ color: 0x9b59b6 })  // Back - Purple
                ];
                
                this.viewCubeMesh = new THREE.Mesh(geometry, materials);
                this.viewCubeScene.add(this.viewCubeMesh);
                
                // Add edges for better visibility
                const edges = new THREE.EdgesGeometry(geometry);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
                const wireframe = new THREE.LineSegments(edges, lineMaterial);
                this.viewCubeMesh.add(wireframe);
                
                // Mouse interaction with ViewCube
                canvas.addEventListener('click', (event) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera({ x, y }, this.viewCubeCamera);
                    const intersects = raycaster.intersectObject(this.viewCubeMesh);
                    
                    if (intersects.length > 0) {
                        const faceIndex = Math.floor(intersects[0].faceIndex / 2);
                        const views = ['right', 'left', 'top', 'bottom', 'front', 'back'];
                        this.setView(views[faceIndex]);
                    }
                });
                
                // Render ViewCube initially
                this.renderViewCube();
            }
            
            renderViewCube() {
                if (!this.viewCubeMesh || !this.viewCubeRenderer) return;
                
                // Sync ViewCube rotation with main camera
                const mainCameraDir = new THREE.Vector3();
                this.camera.getWorldDirection(mainCameraDir);
                
                // Copy main camera rotation to ViewCube
                this.viewCubeMesh.quaternion.copy(this.camera.quaternion);
                this.viewCubeMesh.quaternion.invert();
                
                this.viewCubeRenderer.render(this.viewCubeScene, this.viewCubeCamera);
            }
            
            setView(viewName) {
                const { width, height, depth } = this.mountingConfig;
                const distance = Math.max(width, height, depth) * 1.5;
                
                // Store target for smooth transition
                const targetPos = { x: 0, y: 0, z: 0 };
                const targetLookAt = { x: 0, y: height / 2, z: 0 };
                
                switch(viewName) {
                    case 'top':
                        targetPos.x = 0;
                        targetPos.y = distance;
                        targetPos.z = 0;
                        break;
                    case 'bottom':
                        targetPos.x = 0;
                        targetPos.y = -distance;
                        targetPos.z = 0;
                        break;
                    case 'front':
                        targetPos.x = 0;
                        targetPos.y = height / 2;
                        targetPos.z = distance;
                        break;
                    case 'back':
                        targetPos.x = 0;
                        targetPos.y = height / 2;
                        targetPos.z = -distance;
                        break;
                    case 'left':
                        targetPos.x = -distance;
                        targetPos.y = height / 2;
                        targetPos.z = 0;
                        break;
                    case 'right':
                        targetPos.x = distance;
                        targetPos.y = height / 2;
                        targetPos.z = 0;
                        break;
                }
                
                // Animate camera to new position
                this.animateCamera(targetPos, targetLookAt);
                this.log(`üì∑ View changed to: ${viewName.toUpperCase()}`, 'info');
            }
            
            animateCamera(targetPos, targetLookAt) {
                const startPos = this.camera.position.clone();
                const startLookAt = this.orbitControls.target.clone();
                
                const duration = 800; // ms
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Ease-in-out function
                    const eased = progress < 0.5 
                        ? 4 * progress * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                    
                    // Interpolate camera position
                    this.camera.position.x = startPos.x + (targetPos.x - startPos.x) * eased;
                    this.camera.position.y = startPos.y + (targetPos.y - startPos.y) * eased;
                    this.camera.position.z = startPos.z + (targetPos.z - startPos.z) * eased;
                    
                    // Interpolate look-at target
                    this.orbitControls.target.x = startLookAt.x + (targetLookAt.x - startLookAt.x) * eased;
                    this.orbitControls.target.y = startLookAt.y + (targetLookAt.y - startLookAt.y) * eased;
                    this.orbitControls.target.z = startLookAt.z + (targetLookAt.z - startLookAt.z) * eased;
                    
                    this.orbitControls.update();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                };
                
                animate();
            }
            
            switchTo2DView() {
                this.is2DMode = true;
                const { width, height, depth } = this.mountingConfig;
                const distance = Math.max(width, depth) * 2;
                
                // Top-down orthographic-like view
                this.animateCamera(
                    { x: 0, y: distance, z: 0 },
                    { x: 0, y: 0, z: 0 }
                );
                
                // Restrict orbit controls for 2D mode
                this.orbitControls.enableRotate = false;
                this.orbitControls.maxPolarAngle = 0; // Lock to top view
                this.orbitControls.minPolarAngle = 0;
                
                this.log('üìê Switched to 2D Top View - Arrange items easily!', 'info');
            }
            
            switchTo3DView() {
                this.is2DMode = false;
                const { width, height, depth } = this.mountingConfig;
                const distance = Math.max(width, height, depth) * 1.5;
                
                // 3D perspective view
                this.animateCamera(
                    { x: distance * 0.7, y: distance * 0.5, z: distance * 0.7 },
                    { x: 0, y: height / 2, z: 0 }
                );
                
                // Re-enable orbit controls for 3D mode
                this.orbitControls.enableRotate = true;
                this.orbitControls.maxPolarAngle = Math.PI; // Full rotation
                this.orbitControls.minPolarAngle = 0;
                
                this.log('üé≤ Switched to 3D View - See your assembly in 3D!', 'success');
            }
            
            setupMousePicking() {
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                
                this.renderer.domElement.addEventListener('click', (event) => {
                    if (this.transformControls.dragging) return;
                    
                    const rect = this.renderer.domElement.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, this.camera);
                    const intersects = raycaster.intersectObjects(this.sceneObjects, true);
                    
                    if (intersects.length > 0) {
                        // Find the top-level parent object (for OBJ groups)
                        let selectedObj = intersects[0].object;
                        while (selectedObj.parent && !this.sceneObjects.includes(selectedObj)) {
                            selectedObj = selectedObj.parent;
                        }
                        
                        // Port Edit Mode: Add port at click position
                        if (this.portEditMode) {
                            const clickPosition = intersects[0].point;
                            this.addPortToModel(selectedObj, clickPosition, event.shiftKey);
                        } else {
                            // Normal mode: Select object
                            this.selectObject(selectedObj);
                        }
                    } else {
                        this.deselectObject();
                    }
                });
            }
            
            async setupPhysics() {
                try {
                    await RAPIER.init();
                    const gravity = { x: 0.0, y: -9.81, z: 0.0 };
                    this.world = new RAPIER.World(gravity);
                    this.log('‚úÖ Physics engine initialized', 'success');
                } catch (error) {
                    this.log('‚ö†Ô∏è Physics engine not available', 'warning');
                }
            }
            
            createMounting() {
                const { type, width, height, depth } = this.mountingConfig;
                const wallThickness = 5;
                
                // Clear existing mounting structures
                this.mountingSurfaces.forEach(wall => this.scene.remove(wall));
                this.boundaryWalls.forEach(wall => {
                    this.scene.remove(wall);
                    if (this.world) {
                        const body = this.rigidBodies.get(wall);
                        if (body) this.world.removeRigidBody(body);
                    }
                });
                this.mountingSurfaces = [];
                this.boundaryWalls = [];
                
                if (type === 'box') {
                    this.createBox(width, height, depth, wallThickness);
                } else if (type === 'plate') {
                    this.createPlate(width, height, wallThickness);
                } else if (type === 'shelf') {
                    this.createShelf(width, height, depth, wallThickness);
                }
                
                // Add/update grid helper
                const existingGrid = this.scene.children.find(obj => obj.type === 'GridHelper');
                if (existingGrid) this.scene.remove(existingGrid);
                
                const gridSize = Math.max(width, depth);
                const gridHelper = new THREE.GridHelper(gridSize, 20, 0x444444, 0x222222);
                gridHelper.position.y = 1;
                this.scene.add(gridHelper);
                
                this.log(`‚úÖ ${type.toUpperCase()} created: ${width}√ó${height}√ó${depth}mm`, 'success');
            }
            
            createBox(width, height, depth, thickness) {
                // Back wall (mounting plate) - visible
                const backWall = this.createWall(width, height, thickness, 0x3498db, true);
                backWall.position.set(0, height / 2, -depth / 2);
                backWall.userData.isMountingSurface = true;
                backWall.userData.normal = new THREE.Vector3(0, 0, 1);
                this.mountingSurfaces.push(backWall);
                
                // Bottom floor - visible
                const floor = this.createWall(width, thickness, depth, 0x34495e, true);
                floor.position.set(0, 0, 0);
                floor.userData.isMountingSurface = true;
                floor.userData.normal = new THREE.Vector3(0, 1, 0);
                this.mountingSurfaces.push(floor);
                
                // Side walls - visible
                const leftWall = this.createWall(thickness, height, depth, 0x2c3e50, true);
                leftWall.position.set(-width / 2, height / 2, 0);
                leftWall.userData.isMountingSurface = true;
                leftWall.userData.normal = new THREE.Vector3(1, 0, 0);
                this.mountingSurfaces.push(leftWall);
                
                const rightWall = this.createWall(thickness, height, depth, 0x2c3e50, true);
                rightWall.position.set(width / 2, height / 2, 0);
                rightWall.userData.isMountingSurface = true;
                rightWall.userData.normal = new THREE.Vector3(-1, 0, 0);
                this.mountingSurfaces.push(rightWall);
                
                // Top boundary (invisible collision)
                const topWall = this.createWall(width, thickness, depth, 0xff0000, false);
                topWall.position.set(0, height, 0);
                topWall.visible = false;
                this.boundaryWalls.push(topWall);
                
                // Front boundary (invisible collision) 
                const frontWall = this.createWall(width, height, thickness, 0xff0000, false);
                frontWall.position.set(0, height / 2, depth / 2);
                frontWall.visible = false;
                this.boundaryWalls.push(frontWall);
            }
            
            createPlate(width, height, thickness) {
                // Just a back plate - vertical mounting surface
                const plate = this.createWall(width, height, thickness, 0x3498db, true);
                plate.position.set(0, height / 2, 0);
                plate.userData.isMountingSurface = true;
                plate.userData.normal = new THREE.Vector3(0, 0, 1);
                this.mountingSurfaces.push(plate);
                
                // Floor for catching objects
                const floor = this.createWall(width * 2, thickness, width * 2, 0x34495e, true);
                floor.position.set(0, -50, 0);
                floor.userData.isMountingSurface = true;
                floor.userData.normal = new THREE.Vector3(0, 1, 0);
                this.mountingSurfaces.push(floor);
            }
            
            createShelf(width, height, depth, thickness) {
                // Back wall
                const backWall = this.createWall(width, height, thickness, 0x3498db, true);
                backWall.position.set(0, height / 2, -depth / 2);
                backWall.userData.isMountingSurface = true;
                backWall.userData.normal = new THREE.Vector3(0, 0, 1);
                this.mountingSurfaces.push(backWall);
                
                // Bottom shelf
                const floor = this.createWall(width, thickness, depth, 0x34495e, true);
                floor.position.set(0, 0, 0);
                floor.userData.isMountingSurface = true;
                floor.userData.normal = new THREE.Vector3(0, 1, 0);
                this.mountingSurfaces.push(floor);
                
                // Side walls
                const leftWall = this.createWall(thickness, height, depth, 0x2c3e50, true);
                leftWall.position.set(-width / 2, height / 2, 0);
                leftWall.userData.isMountingSurface = true;
                leftWall.userData.normal = new THREE.Vector3(1, 0, 0);
                this.mountingSurfaces.push(leftWall);
                
                const rightWall = this.createWall(thickness, height, depth, 0x2c3e50, true);
                rightWall.position.set(width / 2, height / 2, 0);
                rightWall.userData.isMountingSurface = true;
                rightWall.userData.normal = new THREE.Vector3(-1, 0, 0);
                this.mountingSurfaces.push(rightWall);
                
                // Top boundary (invisible)
                const topWall = this.createWall(width, thickness, depth, 0xff0000, false);
                topWall.position.set(0, height, 0);
                topWall.visible = false;
                this.boundaryWalls.push(topWall);
                
                // NO front wall - open front for shelf
            }
            
            createWall(width, height, depth, color, visible = true) {
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    transparent: true,
                    opacity: visible ? 0.3 : 0,
                    side: THREE.DoubleSide
                });
                const wall = new THREE.Mesh(geometry, material);
                wall.receiveShadow = true;
                this.scene.add(wall);
                
                // Add physics body for collision (always, even if invisible)
                if (this.world) {
                    const rigidBodyDesc = RAPIER.RigidBodyDesc.fixed();
                    const rigidBody = this.world.createRigidBody(rigidBodyDesc);
                    const colliderDesc = RAPIER.ColliderDesc.cuboid(width / 2, height / 2, depth / 2);
                    this.world.createCollider(colliderDesc, rigidBody);
                    rigidBody.setTranslation(wall.position, true);
                    this.rigidBodies.set(wall, rigidBody);
                }
                
                return wall;
            }
            
            rebuildMounting() {
                // Save current objects
                const savedObjects = this.sceneObjects.map(obj => ({
                    mesh: obj,
                    position: obj.position.clone(),
                    rotation: obj.rotation.clone()
                }));
                
                // Rebuild mounting structure
                this.createMounting();
                
                // Restore objects and update their physics
                savedObjects.forEach(({ mesh, position, rotation }) => {
                    mesh.position.copy(position);
                    mesh.rotation.copy(rotation);
                    this.updatePhysicsBody(mesh);
                });
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update physics
                if (this.world) {
                    this.world.step();
                    
                    // Sync Three.js meshes with physics bodies
                    this.sceneObjects.forEach(obj => {
                        const body = this.rigidBodies.get(obj);
                        if (body) {
                            // Check if object is being dragged by transform controls
                            const isDragging = this.selectedObject === obj && this.transformControls.dragging;
                            
                            if (isDragging) {
                                // User is dragging - update physics from mesh position
                                body.setTranslation(obj.position, true);
                                body.setRotation(obj.quaternion, true);
                                body.setLinvel({ x: 0, y: 0, z: 0 }, true);
                                body.setAngvel({ x: 0, y: 0, z: 0 }, true);
                            } else {
                                // Physics controls the mesh
                                const position = body.translation();
                                obj.position.set(position.x, position.y, position.z);
                                const rotation = body.rotation();
                                obj.quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);
                            }
                            
                            // Always enforce boundaries
                            this.enforceObjectBoundaries(obj);
                        }
                    });
                }
                
                this.orbitControls.update();
                this.renderer.render(this.scene, this.camera);
                
                // Update ViewCube to match main camera rotation
                this.renderViewCube();
            }
            
            enforceObjectBoundaries(obj) {
                // Ensure object stays within mounting boundaries
                const { width, height, depth } = this.mountingConfig;
                const size = obj.userData.size || new THREE.Vector3(50, 50, 50);
                
                const halfWidth = width / 2;
                const halfDepth = depth / 2;
                
                let corrected = false;
                
                // X boundaries (left/right)
                if (obj.position.x - size.x / 2 < -halfWidth) {
                    obj.position.x = -halfWidth + size.x / 2;
                    corrected = true;
                }
                if (obj.position.x + size.x / 2 > halfWidth) {
                    obj.position.x = halfWidth - size.x / 2;
                    corrected = true;
                }
                
                // Y boundaries (floor/ceiling)
                if (obj.position.y - size.y / 2 < 0) {
                    obj.position.y = size.y / 2;
                    corrected = true;
                }
                if (obj.position.y + size.y / 2 > height) {
                    obj.position.y = height - size.y / 2;
                    corrected = true;
                }
                
                // Z boundaries (back/front) - only for box and shelf
                if (this.mountingConfig.type !== 'plate') {
                    if (obj.position.z - size.z / 2 < -halfDepth) {
                        obj.position.z = -halfDepth + size.z / 2;
                        corrected = true;
                    }
                    if (obj.position.z + size.z / 2 > halfDepth) {
                        obj.position.z = halfDepth - size.z / 2;
                        corrected = true;
                    }
                }
                
                // Update physics body if corrected
                if (corrected) {
                    this.updatePhysicsBody(obj);
                }
            }
            
            async loadSTL(file, name, modelData) {
                try {
                    this.log(`üîÑ Loading ${name}...`, 'info');
                    
                    const loader = new THREE.STLLoader();
                    const geometry = await new Promise((resolve, reject) => {
                        loader.load(file, resolve, undefined, reject);
                    });
                    
                    geometry.computeVertexNormals();
                    geometry.center();
                    
                    const material = new THREE.MeshPhongMaterial({
                        color: 0x00aaff,
                        specular: 0x111111,
                        shininess: 200
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    mesh.userData.name = name;
                    mesh.userData.modelData = modelData;
                    
                    // Calculate mesh size
                    geometry.computeBoundingBox();
                    const bbox = geometry.boundingBox;
                    const size = new THREE.Vector3();
                    bbox.getSize(size);
                    
                    // Position on floor with slight random X/Z offset to prevent stacking
                    // Since geometry is centered, bottom is at -size.y/2, so position at size.y/2 to put bottom at Y=0
                    const randomOffset = (Math.random() - 0.5) * 100;
                    mesh.position.set(randomOffset, size.y / 2 + 2, randomOffset);
                    
                    this.scene.add(mesh);
                    this.sceneObjects.push(mesh);
                    
                    // Add physics body
                    this.addPhysicsBody(mesh, geometry);
                    
                    this.log(`‚úÖ ${name} loaded and placed on floor!`, 'success');
                    this.updateSceneObjectsList();
                    // Don't auto-select - let it rest on floor naturally
                    // this.selectObject(mesh);
                    
                } catch (error) {
                    this.log(`‚ùå Failed to load ${name}: ${error.message}`, 'error');
                }
            }
            
            async loadOBJ(objFile, mtlFile, name, modelData) {
                try {
                    this.log(`üîÑ Loading ${name} (OBJ+MTL with materials)...`, 'info');
                    
                    // Extract directory path from objFile for MTL texture loading
                    const objPath = objFile.substring(0, objFile.lastIndexOf('/') + 1);
                    
                    // Load MTL file first
                    const mtlLoader = new THREE.MTLLoader();
                    mtlLoader.setPath(objPath);
                    
                    const materials = await new Promise((resolve, reject) => {
                        mtlLoader.load(
                            mtlFile.split('/').pop(), // Just filename for MTL
                            resolve,
                            undefined,
                            reject
                        );
                    });
                    
                    materials.preload();
                    this.log(`‚úÖ Materials loaded for ${name}`, 'info');
                    
                    // Load OBJ file with materials
                    const objLoader = new THREE.OBJLoader();
                    objLoader.setMaterials(materials);
                    
                    const object = await new Promise((resolve, reject) => {
                        objLoader.load(objFile, resolve, undefined, reject);
                    });
                    
                    // Process the loaded object
                    object.traverse((child) => {
                        if (child instanceof THREE.Mesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            // Ensure material has emissive property for selection
                            if (child.material && !child.material.emissive) {
                                child.material.emissive = new THREE.Color(0x000000);
                            }
                        }
                    });
                    
                    object.userData.name = name;
                    object.userData.modelData = modelData;
                    
                    // SCALE UP: OBJ files are often in meters, we need millimeters
                    // Scale by 1000 to convert meters to millimeters
                    object.scale.set(1000, 1000, 1000);
                    
                    // Calculate bounding box AFTER scaling
                    const bbox = new THREE.Box3().setFromObject(object);
                    const size = new THREE.Vector3();
                    bbox.getSize(size);
                    
                    this.log(`üìè Object size after scaling: ${size.x.toFixed(1)}√ó${size.y.toFixed(1)}√ó${size.z.toFixed(1)}mm`, 'info');
                    
                    // Center the object horizontally, but keep bottom at Y=0
                    const center = new THREE.Vector3();
                    bbox.getCenter(center);
                    
                    // Only center X and Z, adjust Y to put bottom at origin
                    object.position.set(-center.x, -bbox.min.y, -center.z);
                    
                    // Position on floor with random offset
                    const randomOffset = (Math.random() - 0.5) * 100;
                    object.position.add(new THREE.Vector3(randomOffset, 2, randomOffset));
                    
                    this.scene.add(object);
                    this.sceneObjects.push(object);
                    
                    // Add physics body using bounding box
                    this.addPhysicsBodyFromBBox(object, size);
                    
                    this.log(`‚úÖ ${name} loaded! Size: ${size.x.toFixed(1)}√ó${size.y.toFixed(1)}√ó${size.z.toFixed(1)}mm`, 'success');
                    this.log(`üìç Position: (${object.position.x.toFixed(1)}, ${object.position.y.toFixed(1)}, ${object.position.z.toFixed(1)})`, 'info');
                    this.updateSceneObjectsList();
                    
                    // Select the object so user can see it
                    this.selectObject(object);
                    
                } catch (error) {
                    this.log(`‚ùå Failed to load ${name}: ${error.message}`, 'error');
                    console.error('OBJ/MTL loading error:', error);
                }
            }
            
            addPhysicsBodyFromBBox(object, size) {
                // Store size even if physics is not available
                object.userData.size = size;
                
                if (!this.world) {
                    this.log(`‚ö†Ô∏è Physics not available for ${object.userData.name}, object will be static`, 'warning');
                    return;
                }
                
                const rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic()
                    .setTranslation(object.position.x, object.position.y, object.position.z)
                    .setLinearDamping(2.0)
                    .setAngularDamping(2.0);
                const rigidBody = this.world.createRigidBody(rigidBodyDesc);
                
                const colliderDesc = RAPIER.ColliderDesc.cuboid(size.x / 2, size.y / 2, size.z / 2)
                    .setRestitution(0.1)
                    .setFriction(0.9)
                    .setDensity(1.0);
                this.world.createCollider(colliderDesc, rigidBody);
                
                this.rigidBodies.set(object, rigidBody);
            }
            
            addPhysicsBody(mesh, geometry) {
                // Compute bounding box for collider
                geometry.computeBoundingBox();
                const bbox = geometry.boundingBox;
                const size = new THREE.Vector3();
                bbox.getSize(size);
                
                // Store size for boundary checking
                mesh.userData.size = size;
                
                if (!this.world) {
                    this.log(`‚ö†Ô∏è Physics not available for ${mesh.userData.name}, object will be static`, 'warning');
                    return;
                }
                
                const rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic()
                    .setTranslation(mesh.position.x, mesh.position.y, mesh.position.z)
                    .setLinearDamping(2.0) // Add damping to reduce bouncing
                    .setAngularDamping(2.0);
                const rigidBody = this.world.createRigidBody(rigidBodyDesc);
                
                const colliderDesc = RAPIER.ColliderDesc.cuboid(size.x / 2, size.y / 2, size.z / 2)
                    .setRestitution(0.1) // Low bounce
                    .setFriction(0.9) // High friction to prevent sliding
                    .setDensity(1.0);
                this.world.createCollider(colliderDesc, rigidBody);
                
                this.rigidBodies.set(mesh, rigidBody);
            }
            
            updatePhysicsBody(mesh) {
                const body = this.rigidBodies.get(mesh);
                if (body) {
                    body.setTranslation(mesh.position, true);
                    body.setRotation(mesh.quaternion, true);
                    body.setLinvel({ x: 0, y: 0, z: 0 }, true);
                    body.setAngvel({ x: 0, y: 0, z: 0 }, true);
                    
                    // Check boundaries when manually moving
                    this.enforceObjectBoundaries(mesh);
                }
            }
            
            checkSnapping(mesh) {
                if (!this.snapEnabled) return;
                
                const meshBox = new THREE.Box3().setFromObject(mesh);
                const meshSize = new THREE.Vector3();
                meshBox.getSize(meshSize);
                
                for (const surface of this.mountingSurfaces) {
                    const surfaceBox = new THREE.Box3().setFromObject(surface);
                    
                    // Snap to back wall (mounting plate)
                    if (surface.userData.normal && surface.userData.normal.z > 0.9) {
                        const targetZ = surfaceBox.max.z + meshSize.z / 2 + 2;
                        const distanceToSurface = Math.abs(meshBox.min.z - surfaceBox.max.z);
                        
                        if (distanceToSurface < this.snapDistance) {
                            mesh.position.z = targetZ;
                            this.log(`üß≤ Snapped ${mesh.userData.name} to mounting plate`, 'success');
                        }
                    }
                    // Snap to floor
                    else if (surface.userData.normal && surface.userData.normal.y > 0.9) {
                        const distanceToFloor = Math.abs(meshBox.min.y - surfaceBox.max.y);
                        
                        if (distanceToFloor < this.snapDistance) {
                            // Calculate the offset needed to move bottom of object to floor surface
                            const bottomOffset = meshBox.min.y - mesh.position.y;
                            const targetY = surfaceBox.max.y - bottomOffset;
                            mesh.position.y = targetY;
                            this.log(`üß≤ Snapped ${mesh.userData.name} to floor`, 'success');
                        }
                    }
                    // Snap to side walls
                    else if (surface.userData.normal) {
                        // Left wall (normal points right, +X)
                        if (surface.userData.normal.x > 0.9) {
                            const targetX = surfaceBox.max.x + meshSize.x / 2 + 2;
                            const distanceToWall = Math.abs(meshBox.min.x - surfaceBox.max.x);
                            
                            if (distanceToWall < this.snapDistance) {
                                mesh.position.x = targetX;
                                this.log(`üß≤ Snapped ${mesh.userData.name} to left wall`, 'success');
                            }
                        }
                        // Right wall (normal points left, -X)
                        else if (surface.userData.normal.x < -0.9) {
                            const targetX = surfaceBox.min.x - meshSize.x / 2 - 2;
                            const distanceToWall = Math.abs(meshBox.max.x - surfaceBox.min.x);
                            
                            if (distanceToWall < this.snapDistance) {
                                mesh.position.x = targetX;
                                this.log(`üß≤ Snapped ${mesh.userData.name} to right wall`, 'success');
                            }
                        }
                    }
                }
            }
            
            selectObject(obj) {
                if (this.selectedObject === obj) return;
                
                this.deselectObject();
                this.selectedObject = obj;
                this.transformControls.attach(obj);
                
                // Highlight selected object (handle both Mesh and Group)
                if (obj.material) {
                    // Single Mesh (STL files)
                    obj.material.emissive = new THREE.Color(0x00ff00);
                    obj.material.emissiveIntensity = 0.3;
                } else {
                    // Group with multiple meshes (OBJ files)
                    obj.traverse((child) => {
                        if (child instanceof THREE.Mesh && child.material) {
                            if (child.material.emissive) {
                                child.material.emissive = new THREE.Color(0x00ff00);
                                child.material.emissiveIntensity = 0.3;
                            }
                        }
                    });
                }
                
                this.log(`‚úÖ Selected: ${obj.userData.name}`, 'info');
                this.updatePropertiesPanel();
            }
            
            deselectObject() {
                if (this.selectedObject) {
                    // Remove highlight (handle both Mesh and Group)
                    if (this.selectedObject.material) {
                        // Single Mesh (STL files)
                        this.selectedObject.material.emissive = new THREE.Color(0x000000);
                    } else {
                        // Group with multiple meshes (OBJ files)
                        this.selectedObject.traverse((child) => {
                            if (child instanceof THREE.Mesh && child.material) {
                                if (child.material.emissive) {
                                    child.material.emissive = new THREE.Color(0x000000);
                                }
                            }
                        });
                    }
                    
                    this.transformControls.detach();
                    this.selectedObject = null;
                    this.updatePropertiesPanel();
                }
            }
            
            updatePropertiesPanel() {
                const panel = document.getElementById('model-properties-content');
                if (!panel) return;
                
                if (this.selectedObject) {
                    const obj = this.selectedObject;
                    const pos = obj.position;
                    const rot = obj.rotation;
                    
                    panel.innerHTML = `
                        <div style="padding: 10px; font-size: 12px;">
                            <h3 style="margin-top: 0; color: #2ecc71;">${obj.userData.name}</h3>
                            <div style="margin: 10px 0;">
                                <strong>Position (mm):</strong><br>
                                X: ${pos.x.toFixed(1)}<br>
                                Y: ${pos.y.toFixed(1)}<br>
                                Z: ${pos.z.toFixed(1)}
                            </div>
                            <div style="margin: 10px 0;">
                                <strong>Rotation (deg):</strong><br>
                                X: ${(rot.x * 180 / Math.PI).toFixed(1)}¬∞<br>
                                Y: ${(rot.y * 180 / Math.PI).toFixed(1)}¬∞<br>
                                Z: ${(rot.z * 180 / Math.PI).toFixed(1)}¬∞
                            </div>
                            <div style="margin-top: 15px;">
                                <button onclick="viewer3D.transformControls.setMode('translate')" class="btn btn-secondary btn-small">Move</button>
                                <button onclick="viewer3D.transformControls.setMode('rotate')" class="btn btn-secondary btn-small">Rotate</button>
                            </div>
                            <button onclick="viewer3D.deleteSelected()" class="btn btn-danger btn-small" style="margin-top: 10px; width: 100%;">Delete</button>
                        </div>
                    `;
                } else {
                    panel.innerHTML = '<p class="empty-message">Select a component to view properties</p>';
                }
            }
            
            updateSceneObjectsList() {
                const list = document.getElementById('scene-objects-list');
                if (!list) return;
                
                if (this.sceneObjects.length === 0) {
                    list.innerHTML = '<p class="empty-message">No objects in scene</p>';
                } else {
                    list.innerHTML = this.sceneObjects.map((obj, index) => `
                        <div style="padding: 5px; margin: 3px 0; background: #34495e; border-radius: 3px; cursor: pointer; font-size: 11px;"
                             onclick="viewer3D.selectObject(viewer3D.sceneObjects[${index}])">
                            ${obj.userData.name}
                        </div>
                    `).join('');
                }
            }
            
            deleteSelected() {
                if (!this.selectedObject) return;
                
                const obj = this.selectedObject;
                this.scene.remove(obj);
                const index = this.sceneObjects.indexOf(obj);
                if (index > -1) this.sceneObjects.splice(index, 1);
                
                // Remove physics body
                const body = this.rigidBodies.get(obj);
                if (body && this.world) {
                    this.world.removeRigidBody(body);
                    this.rigidBodies.delete(obj);
                }
                
                this.log(`üóëÔ∏è Deleted: ${obj.userData.name}`, 'info');
                this.deselectObject();
                this.updateSceneObjectsList();
            }
            
            clearScene() {
                this.sceneObjects.forEach(obj => {
                    this.scene.remove(obj);
                    const body = this.rigidBodies.get(obj);
                    if (body && this.world) {
                        this.world.removeRigidBody(body);
                    }
                });
                this.sceneObjects = [];
                this.rigidBodies.clear();
                this.deselectObject();
                this.updateSceneObjectsList();
                this.log('üóëÔ∏è Scene cleared', 'info');
            }
            
            // ==================== PORT EDITOR METHODS ====================
            
            togglePortEditMode() {
                this.portEditMode = !this.portEditMode;
                const btn = document.getElementById('togglePortEditMode');
                const controls = document.getElementById('portEditorControls');
                
                if (this.portEditMode) {
                    btn.textContent = 'üìç Edit Ports Mode: ON';
                    btn.classList.remove('btn-secondary');
                    btn.classList.add('btn-success');
                    controls.style.display = 'block';
                    this.log('üîå Port Edit Mode ENABLED - Click on models to add ports', 'success');
                } else {
                    btn.textContent = 'üìç Edit Ports Mode: OFF';
                    btn.classList.remove('btn-success');
                    btn.classList.add('btn-secondary');
                    controls.style.display = 'none';
                    this.log('üîå Port Edit Mode DISABLED', 'info');
                }
            }
            
            addPortToModel(modelObj, worldPosition, shiftKey = false) {
                if (!this.portEditMode) return;
                
                const modelName = modelObj.userData.modelData?.name || modelObj.userData.name;
                
                // Shift+Click removes nearest port
                if (shiftKey) {
                    this.removeNearestPort(modelName, worldPosition);
                    return;
                }
                
                // Get port configuration
                const label = document.getElementById('portLabel').value || 'Port';
                const type = document.getElementById('portType').value;
                const size = parseFloat(document.getElementById('portSize').value) || 10;
                
                // Convert world position to local position relative to model
                const localPosition = modelObj.worldToLocal(worldPosition.clone());
                
                // Initialize ports array for this model if needed
                if (!this.modelPorts.has(modelName)) {
                    this.modelPorts.set(modelName, []);
                }
                
                const port = {
                    label: label,
                    type: type,
                    size: size,
                    localPosition: { x: localPosition.x, y: localPosition.y, z: localPosition.z },
                    worldPosition: { x: worldPosition.x, y: worldPosition.y, z: worldPosition.z }
                };
                
                this.modelPorts.get(modelName).push(port);
                this.createPortMarker(modelObj, port);
                this.updatePortsList();
                
                this.log(`‚úÖ Added port "${label}" to ${modelName}`, 'success');
                
                // Clear label for next port
                document.getElementById('portLabel').value = '';
            }
            
            removeNearestPort(modelName, worldPosition) {
                const ports = this.modelPorts.get(modelName);
                if (!ports || ports.length === 0) return;
                
                // Find nearest port
                let nearestIndex = -1;
                let minDistance = Infinity;
                
                ports.forEach((port, index) => {
                    const dx = port.worldPosition.x - worldPosition.x;
                    const dy = port.worldPosition.y - worldPosition.y;
                    const dz = port.worldPosition.z - worldPosition.z;
                    const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestIndex = index;
                    }
                });
                
                if (nearestIndex >= 0 && minDistance < 30) { // Within 30mm
                    const removedPort = ports.splice(nearestIndex, 1)[0];
                    this.updatePortMarkers();
                    this.updatePortsList();
                    this.log(`üóëÔ∏è Removed port "${removedPort.label}" from ${modelName}`, 'warning');
                }
            }
            
            createPortMarker(modelObj, port) {
                const geometry = new THREE.PlaneGeometry(port.size, port.size);
                const color = this.getPortColor(port.type);
                const material = new THREE.MeshBasicMaterial({ 
                    color: color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });
                
                const marker = new THREE.Mesh(geometry, material);
                marker.position.set(port.worldPosition.x, port.worldPosition.y, port.worldPosition.z);
                marker.userData.isPortMarker = true;
                marker.userData.portLabel = port.label;
                
                // Add text label
                this.addPortLabel(marker, port.label);
                
                this.scene.add(marker);
                this.portMarkers.push(marker);
            }
            
            addPortLabel(marker, text) {
                // Create canvas for text
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 128;
                
                context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.font = 'Bold 48px Arial';
                context.fillStyle = 'white';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, 128, 64);
                
                const texture = new THREE.CanvasTexture(canvas);
                const labelMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(labelMaterial);
                sprite.scale.set(20, 10, 1);
                sprite.position.set(0, 0, 1);
                
                marker.add(sprite);
            }
            
            getPortColor(type) {
                const colors = {
                    'power': 0xff0000,    // Red
                    'input': 0x00ff00,    // Green
                    'output': 0x0000ff,   // Blue
                    'data': 0xffff00      // Yellow
                };
                return colors[type] || 0xffffff;
            }
            
            updatePortMarkers() {
                // Remove all existing markers
                this.portMarkers.forEach(marker => this.scene.remove(marker));
                this.portMarkers = [];
                
                // Recreate markers for all ports
                this.modelPorts.forEach((ports, modelName) => {
                    const modelObj = this.sceneObjects.find(obj => 
                        (obj.userData.modelData?.name || obj.userData.name) === modelName
                    );
                    
                    if (modelObj) {
                        ports.forEach(port => this.createPortMarker(modelObj, port));
                    }
                });
            }
            
            updatePortsList() {
                const listDiv = document.getElementById('portsList');
                if (!listDiv) return;
                
                listDiv.innerHTML = '';
                
                if (this.modelPorts.size === 0) {
                    listDiv.innerHTML = '<p style="color: #888; font-size: 10px;">No ports defined</p>';
                    return;
                }
                
                this.modelPorts.forEach((ports, modelName) => {
                    if (ports.length > 0) {
                        const modelSection = document.createElement('div');
                        modelSection.style.marginBottom = '10px';
                        modelSection.innerHTML = `<strong style="color: #3498db;">${modelName}:</strong>`;
                        
                        ports.forEach(port => {
                            const portItem = document.createElement('div');
                            portItem.style.marginLeft = '10px';
                            portItem.style.fontSize = '10px';
                            portItem.style.color = '#ecf0f1';
                            
                            const typeIcon = {
                                'power': '‚ö°',
                                'input': 'üì•',
                                'output': 'üì§',
                                'data': 'üíæ'
                            }[port.type] || 'üîå';
                            
                            portItem.textContent = `${typeIcon} ${port.label}`;
                            modelSection.appendChild(portItem);
                        });
                        
                        listDiv.appendChild(modelSection);
                    }
                });
            }
            
            exportPortsConfig() {
                const config = {};
                
                this.modelPorts.forEach((ports, modelName) => {
                    config[modelName] = ports.map(port => ({
                        label: port.label,
                        type: port.type,
                        size: port.size,
                        localPosition: port.localPosition
                    }));
                });
                
                const json = JSON.stringify(config, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'model-ports-config.json';
                a.click();
                
                URL.revokeObjectURL(url);
                this.log('üíæ Port configuration exported!', 'success');
            }
            
            importPortsConfig(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const config = JSON.parse(e.target.result);
                        
                        // Clear existing ports
                        this.modelPorts.clear();
                        
                        // Load ports from config
                        Object.keys(config).forEach(modelName => {
                            this.modelPorts.set(modelName, []);
                            
                            config[modelName].forEach(portData => {
                                // Find the model object
                                const modelObj = this.sceneObjects.find(obj => 
                                    (obj.userData.modelData?.name || obj.userData.name) === modelName
                                );
                                
                                if (modelObj) {
                                    // Convert local to world position
                                    const localPos = new THREE.Vector3(
                                        portData.localPosition.x,
                                        portData.localPosition.y,
                                        portData.localPosition.z
                                    );
                                    const worldPos = modelObj.localToWorld(localPos.clone());
                                    
                                    const port = {
                                        label: portData.label,
                                        type: portData.type,
                                        size: portData.size,
                                        localPosition: portData.localPosition,
                                        worldPosition: { x: worldPos.x, y: worldPos.y, z: worldPos.z }
                                    };
                                    
                                    this.modelPorts.get(modelName).push(port);
                                }
                            });
                        });
                        
                        this.updatePortMarkers();
                        this.updatePortsList();
                        this.log('üìÅ Port configuration imported!', 'success');
                        
                    } catch (error) {
                        this.log(`‚ùå Failed to import config: ${error.message}`, 'error');
                    }
                };
                reader.readAsText(file);
            }
            
            // ==================== END PORT EDITOR METHODS ====================
            
            log(message, type = 'info') {
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                entry.style.color = type === 'success' ? '#2ecc71' :
                                   type === 'error' ? '#e74c3c' :
                                   type === 'warning' ? '#f39c12' : '#3498db';
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                this.statusDiv.appendChild(entry);
                this.statusDiv.scrollTop = this.statusDiv.scrollHeight;
                
                // Keep only last 20 messages
                while (this.statusDiv.children.length > 20) {
                    this.statusDiv.removeChild(this.statusDiv.firstChild);
                }
            }
        }
        
        // STL Model Catalog (inline version)
        class STLModelCatalog {
            constructor() {
                this.models = [];
                this.modelsLoaded = false;
            }
            
            async loadCatalog() {
                if (this.modelsLoaded) return this.models;
                
                try {
                    const response = await fetch('libs/model/catalog.json');
                    if (response.ok) {
                        const data = await response.json();
                        this.models = data.models || [];
                    } else {
                        this.models = this.getFallbackModels();
                    }
                    this.modelsLoaded = true;
                    return this.models;
                } catch (error) {
                    this.models = this.getFallbackModels();
                    this.modelsLoaded = true;
                    return this.models;
                }
            }
            
            getFallbackModels() {
                return [
                    { name: 'Motor Controller', file: 'motor-controller.stl', format: 'stl', size: '23MB', type: 'motor' },
                    { name: 'PLC', file: 'plc.stl', format: 'stl', size: '26MB', type: 'cpu' },
                    { name: 'Circuit Breaker', file: 'circuit-breaker.stl', format: 'stl', size: '43MB', type: 'circuit-breaker' },
                    { name: 'Emergency Push Button', file: 'emergency-push-button.stl', format: 'stl', size: '12MB', type: 'button' },
                    { name: 'PCB Mount Relay', file: 'pcb-mount-relay.stl', format: 'stl', size: '0.8MB', type: 'relay' },
                    { name: 'Stack LED Light', file: 'stack-led-light.stl', format: 'stl', size: '14MB', type: 'led' },
                    { name: 'PCB Board', file: 'pcb.obj', mtlFile: 'pcb.mtl', format: 'obj', size: '1MB', type: 'pcb' }
                ];
            }
            
            getAllModels() {
                return this.models;
            }
        }
        
        // Initialize Interactive 3D Scene
        let viewer3D = null;
        const catalog = new STLModelCatalog();
        
        function init3DViewer() {
            if (viewer3D) return; // Already initialized
            
            const container = document.getElementById('model-viewer-container');
            const statusDiv = document.getElementById('model-viewer-status');
            
            viewer3D = new Interactive3DScene(container, statusDiv);
            
            // Setup physics controls
            setupPhysicsControls();
            
            // Setup view mode controls
            setupViewModeControls();
        }
        
        function setupViewModeControls() {
            const view2DBtn = document.getElementById('view2D');
            const view3DBtn = document.getElementById('view3D');
            
            if (view2DBtn && view3DBtn) {
                // Start in 2D mode (button already highlighted)
                view2DBtn.classList.add('btn-success');
                view2DBtn.classList.remove('btn-secondary');
                view3DBtn.classList.remove('btn-success');
                view3DBtn.classList.add('btn-secondary');
                
                view2DBtn.addEventListener('click', () => {
                    if (viewer3D) {
                        viewer3D.switchTo2DView();
                        view2DBtn.classList.add('btn-success');
                        view2DBtn.classList.remove('btn-secondary');
                        view3DBtn.classList.remove('btn-success');
                        view3DBtn.classList.add('btn-secondary');
                    }
                });
                
                view3DBtn.addEventListener('click', () => {
                    if (viewer3D) {
                        viewer3D.switchTo3DView();
                        view3DBtn.classList.add('btn-success');
                        view3DBtn.classList.remove('btn-secondary');
                        view2DBtn.classList.remove('btn-success');
                        view2DBtn.classList.add('btn-secondary');
                    }
                });
            }
        }
        
        function setupPhysicsControls() {
            // Mounting configuration controls
            const mountingType = document.getElementById('mountingType');
            const mountingWidth = document.getElementById('mountingWidth');
            const mountingHeight = document.getElementById('mountingHeight');
            const mountingDepth = document.getElementById('mountingDepth');
            const applyMountingBtn = document.getElementById('applyMounting');
            
            if (applyMountingBtn) {
                applyMountingBtn.addEventListener('click', () => {
                    if (viewer3D) {
                        viewer3D.mountingConfig.type = mountingType.value;
                        viewer3D.mountingConfig.width = parseFloat(mountingWidth.value);
                        viewer3D.mountingConfig.height = parseFloat(mountingHeight.value);
                        viewer3D.mountingConfig.depth = parseFloat(mountingDepth.value);
                        viewer3D.rebuildMounting();
                    }
                });
            }
            
            // Physics controls
            const gravityCheckbox = document.getElementById('enableGravity');
            const snappingCheckbox = document.getElementById('enableSnapping');
            const snapDistanceSlider = document.getElementById('snapDistance');
            const snapDistanceValue = document.getElementById('snapDistanceValue');
            const clearSceneBtn = document.getElementById('clearScene');
            
            if (gravityCheckbox) {
                gravityCheckbox.addEventListener('change', (e) => {
                    if (viewer3D) {
                        viewer3D.gravityEnabled = e.target.checked;
                        viewer3D.log(`‚öôÔ∏è Gravity ${e.target.checked ? 'enabled' : 'disabled'}`, 'info');
                    }
                });
            }
            
            if (snappingCheckbox) {
                snappingCheckbox.addEventListener('change', (e) => {
                    if (viewer3D) {
                        viewer3D.snapEnabled = e.target.checked;
                        viewer3D.log(`üß≤ Snapping ${e.target.checked ? 'enabled' : 'disabled'}`, 'info');
                    }
                });
            }
            
            if (snapDistanceSlider) {
                snapDistanceSlider.addEventListener('input', (e) => {
                    if (viewer3D) {
                        viewer3D.snapDistance = parseFloat(e.target.value);
                        snapDistanceValue.textContent = `${e.target.value}mm`;
                    }
                });
            }
            
            // Port Editor controls
            const togglePortEditBtn = document.getElementById('togglePortEditMode');
            const savePortsBtn = document.getElementById('savePortsToFile');
            const loadPortsBtn = document.getElementById('loadPortsFromFile');
            
            if (togglePortEditBtn) {
                togglePortEditBtn.addEventListener('click', () => {
                    if (viewer3D) {
                        viewer3D.togglePortEditMode();
                    }
                });
            }
            
            if (savePortsBtn) {
                savePortsBtn.addEventListener('click', () => {
                    if (viewer3D) {
                        viewer3D.exportPortsConfig();
                    }
                });
            }
            
            if (loadPortsBtn) {
                loadPortsBtn.addEventListener('click', () => {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.json';
                    input.onchange = (e) => {
                        const file = e.target.files[0];
                        if (file && viewer3D) {
                            viewer3D.importPortsConfig(file);
                        }
                    };
                    input.click();
                });
            }
            
            if (clearSceneBtn) {
                clearSceneBtn.addEventListener('click', () => {
                    if (viewer3D && confirm('Clear all objects from scene?')) {
                        viewer3D.clearScene();
                    }
                });
            }
        }
        
        // Load model catalog and create buttons
        async function loadModelButtons() {
            try {
                const models = await catalog.loadCatalog();
                const container = document.getElementById('model-list-buttons');
                const infoText = document.getElementById('model-catalog-info');
                
                container.innerHTML = '';
                
                models.forEach((model) => {
                    const button = document.createElement('button');
                    button.className = 'btn btn-success btn-block';
                    button.style.cssText = 'margin-bottom: 8px; text-align: left; padding: 10px;';
                    
                    // Show format indicator
                    const formatIcon = model.format === 'obj' ? 'üé®' : 'üì¶';
                    const formatText = model.format === 'obj' ? 'OBJ+MTL' : 'STL';
                    
                    button.innerHTML = `
                        <div style="font-weight: bold; margin-bottom: 3px;">${formatIcon} ${model.name}</div>
                        <div style="font-size: 10px; opacity: 0.8;">${model.size} ‚Ä¢ ${formatText}</div>
                    `;
                    button.onclick = () => {
                        if (viewer3D) {
                            if (model.format === 'obj') {
                                // Load OBJ+MTL
                                // Check if URL is absolute (starts with http/https) or relative
                                const objPath = model.file.startsWith('http') ? model.file : `libs/model/${model.file}`;
                                const mtlPath = model.mtlFile.startsWith('http') ? model.mtlFile : `libs/model/${model.mtlFile}`;
                                viewer3D.loadOBJ(objPath, mtlPath, model.name, model);
                            } else {
                                // Load STL
                                // Check if URL is absolute (starts with http/https) or relative
                                const filePath = model.file.startsWith('http') ? model.file : `libs/model/${model.file}`;
                                viewer3D.loadSTL(filePath, model.name, model);
                            }
                        }
                    };
                    container.appendChild(button);
                });
                
                infoText.textContent = `‚úÖ ${models.length} CAD models available - Click to add to scene`;
                infoText.style.color = '#2ecc71';
                
            } catch (error) {
                console.error('Failed to load model catalog:', error);
            }
        }
        
        // Initialize 3D viewer when needed
        document.addEventListener('DOMContentLoaded', function() {
            // 3D viewer will be initialized by viewSwitching.js when switching to 3D view
            window.init3DModelViewer = function() {
                init3DViewer();
                loadModelButtons();
            };
        });
    </script>
</body>
</html>

